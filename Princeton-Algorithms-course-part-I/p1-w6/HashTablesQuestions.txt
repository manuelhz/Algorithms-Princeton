1) Which of the following is not a property of Java's hashCode() for the String data type?

a) can return a negative integer
Incorrect Java's hashCode() method can return any integer, positive, negative, or zero.
b) can take time proportional to the length of the string to compute
Incorrect
Computing the hash code of a string involves performing arithmetic on each of the characters in the string, which takes time proportional to the length of the string. Once the hash code has been computed for a string, Java typically caches it to avoid having to recompute it from scratch each time.
->c) a string and its reverse will have the same hashCode() value.
Correct
There is no reason to expect this. For example, the strings ab and ba have different hash codes.
d) two strings with different hashCode() values are different strings
Incorrect
Two strings that correspond to the same sequence of characters must have the same hashCode() value.
The converse is not true: different strings can have the same hashCode() value.

2) What is the average running time of a random search miss in a separate-chaining hash table? Assume that your hash function satisfies the uniform hashing assumption and that there are m = n/8 chains.

->a) constant
Correct
This is one of the key properties of a separate-chaining hash table.
b) logarithmic
c) linear
d) linearithmic

3) What is the average running time of delete in a linear-probing hash table? Assume that your hash function satisfies the uniform hashing assumption and that the hash table is at most 50% full.


->a)constant
Correct
The easiest way to implement delete is to find and remove the key–value pair and then to reinsert all of the key–value pairs in the same cluster that appear after the deleted key–value pair. If the hash table doesn't get too full, the expected number of key–value pairs to reinsert will be a small constant.

An alternative is to flag the deleted linear-probing table entry so that it is skipped over during a search but is used for an insertion. If there are too many flagged entries, create a new hash table and rehash all key–value pairs.
b)logarithmic
c)linear
d)linearithmic

4) Which  is the main reason to use a hash table instead of a red–black BST?


a)supports more operations efficiently
b)better worst-case performance guarantee
->c)better performance in practice on typical inputs
Correct
This is the main reason to use a hash table.
d)implementation included in Java libraries

